diff --git a/src/core/config/index.js b/src/core/config/index.js
index 5a6830bdaa42f293edc6b626be38c8aedbc51b5b..ab5d536acf8cceb2845bbeda50aad8b5125cf4e0 100644
--- a/src/core/config/index.js
+++ b/src/core/config/index.js
@@ -3,6 +3,7 @@ import path from 'node:path';
 import process from 'node:process';
 import * as url from 'node:url';
 import options from './options.js';
+import { check_middleware_feature } from '../../utils/features.js';
 
 /**
  * Loads the template (src/app.html by default) and validates that it has the
@@ -95,6 +96,10 @@ function process_config(config, { cwd = process.cwd() } = {}) {
 			validated.kit.files.hooks.client = path.resolve(cwd, validated.kit.files.hooks.client);
 			validated.kit.files.hooks.server = path.resolve(cwd, validated.kit.files.hooks.server);
 			validated.kit.files.hooks.universal = path.resolve(cwd, validated.kit.files.hooks.universal);
+			validated.kit.files.hooks.middleware = path.resolve(
+				cwd,
+				validated.kit.files.hooks.middleware
+			);
 		} else {
 			// @ts-expect-error
 			validated.kit.files[key] = path.resolve(cwd, validated.kit.files[key]);
@@ -130,5 +135,7 @@ export function validate_config(config) {
 		}
 	}
 
+	check_middleware_feature(validated.kit.adapter);
+
 	return validated;
 }
diff --git a/src/core/config/options.js b/src/core/config/options.js
index a2b9bb81759d025a99dc542bcf12816cfb2b3400..2a861c0a6a6d1bb22afaf4130ad4d8b511982fd9 100644
--- a/src/core/config/options.js
+++ b/src/core/config/options.js
@@ -125,7 +125,8 @@ const options = object(
 				hooks: object({
 					client: string(join('src', 'hooks.client')),
 					server: string(join('src', 'hooks.server')),
-					universal: string(join('src', 'hooks'))
+					universal: string(join('src', 'hooks')),
+					middleware: string(join('src', 'hooks.middleware'))
 				}),
 				lib: string(join('src', 'lib')),
 				params: string(join('src', 'params')),
diff --git a/src/core/sync/create_manifest_data/index.js b/src/core/sync/create_manifest_data/index.js
index 037f8dc8f6ba2def9b57bd3eca6780826ac98c13..8e8389e095cc0c486bf43c2cb100ffde4c6aa7dc 100644
--- a/src/core/sync/create_manifest_data/index.js
+++ b/src/core/sync/create_manifest_data/index.js
@@ -64,11 +64,13 @@ function create_hooks(config, cwd) {
 	const client = resolve_entry(config.kit.files.hooks.client);
 	const server = resolve_entry(config.kit.files.hooks.server);
 	const universal = resolve_entry(config.kit.files.hooks.universal);
+	const middleware = resolve_entry(config.kit.files.hooks.middleware);
 
 	return {
 		client: client && posixify(path.relative(cwd, client)),
 		server: server && posixify(path.relative(cwd, server)),
-		universal: universal && posixify(path.relative(cwd, universal))
+		universal: universal && posixify(path.relative(cwd, universal)),
+		middleware: middleware && posixify(path.relative(cwd, middleware))
 	};
 }
 
diff --git a/src/exports/public.d.ts b/src/exports/public.d.ts
index 06bb38fd768c7fb16b162f789c4fa1cf4130b2bf..46913278aadae54702539efc53f04ba65d78c434 100644
--- a/src/exports/public.d.ts
+++ b/src/exports/public.d.ts
@@ -44,6 +44,11 @@ export interface Adapter {
 		 * @param config The merged route config
 		 */
 		read?: (details: { config: any; route: { id: string } }) => boolean;
+		/**
+		 * Test support for middleware
+		 * @since 2.18.0
+		 */
+		middleware?: () => boolean;
 	};
 	/**
 	 * Creates an `Emulator`, which allows the adapter to influence the environment
@@ -435,6 +440,12 @@ export interface KitConfig {
 			 * @since 2.3.0
 			 */
 			universal?: string;
+			/**
+			 * The location of your middleware [hooks](https://svelte.dev/docs/kit/hooks).
+			 * @default "src/hooks.middleware"
+			 * @since 2.18.0
+			 */
+			middleware?: string;
 		};
 		/**
 		 * your app's internal library, accessible throughout the codebase as `$lib`
@@ -1484,7 +1495,7 @@ export type SubmitFunction<
 			 * @param invalidateAll Set `invalidateAll: false` if you don't want the action to call `invalidateAll` after submission.
 			 */
 			update: (options?: { reset?: boolean; invalidateAll?: boolean }) => Promise<void>;
-	  }) => void)
+	  }) => MaybePromise<void>)
 >;
 
 /**
@@ -1495,4 +1506,31 @@ export interface Snapshot<T = any> {
 	restore: (snapshot: T) => void;
 }
 
+export interface Middleware {
+	(options: {
+		request: Request;
+		url: URL;
+		setRequestHeaders: (headers: Record<string, string>) => void;
+		setResponseHeaders: (headers: Record<string, string>) => void;
+		cookies: Cookies;
+		reroute: (pathname: string) => unknown;
+	}): Response | unknown;
+}
+
+export interface CallMiddleware {
+	(
+		request: Request,
+		middleware: Middleware
+	): Promise<
+		| Response
+		| {
+				request: Request;
+				request_headers: Headers;
+				did_reroute: boolean;
+				response_headers: Headers;
+				add_response_headers: (response: Response) => void;
+		  }
+	>;
+}
+
 export * from './index.js';
diff --git a/src/exports/vite/build/build_middleware.js b/src/exports/vite/build/build_middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..6bbcab98e0139d30b72b73727f90ed20b5431233
--- /dev/null
+++ b/src/exports/vite/build/build_middleware.js
@@ -0,0 +1,145 @@
+import * as vite from 'vite';
+import { dedent } from '../../../core/sync/utils.js';
+import { s } from '../../../utils/misc.js';
+import { sveltekit_paths } from '../module_ids.js';
+import { get_config_aliases } from '../utils.js';
+import { posixify } from '../../../utils/filesystem.js';
+import { fileURLToPath } from 'url';
+
+/**
+ * @param {string} out
+ * @param {import('types').ValidatedKitConfig} kit
+ * @param {import('vite').ResolvedConfig} vite_config
+ * @param {string} runtime_directory
+ * @param {string} middleware_entry_file
+ */
+export async function build_middleware(
+	out,
+	kit,
+	vite_config,
+	runtime_directory,
+	middleware_entry_file
+) {
+	/**
+	 * @type {import('vite').Plugin}
+	 */
+	const mw_virtual_modules = {
+		name: 'middleware-build-virtual-modules',
+
+		resolveId(id) {
+			if (
+				id.startsWith('$env/') ||
+				id === '$service-worker' ||
+				(id.startsWith('$app/') && id !== '$app/paths')
+			) {
+				throw new Error(
+					`Cannot import ${id} into middleware code. Only the $app/paths module is available in middleware.`
+				);
+			}
+
+			if (id.startsWith('__sveltekit/')) {
+				return `\0virtual:${id}`;
+			}
+		},
+
+		load(id) {
+			if (!id.startsWith('\0virtual:')) {
+				return;
+			}
+
+			if (id === sveltekit_paths) {
+				const { assets, base } = kit.paths;
+
+				// TODO duplicated in vite/index.js, extract to a shared module?
+				return dedent`
+						export let base = ${s(base)};
+						export let assets = ${assets ? s(assets) : 'base'};
+						export const app_dir = ${s(kit.appDir)};
+
+						export const relative = ${kit.paths.relative};
+
+						const initial = { base, assets };
+
+						export function override(paths) {
+							base = paths.base;
+							assets = paths.assets;
+						}
+
+						export function reset() {
+							base = initial.base;
+							assets = initial.assets;
+						}
+
+						/** @param {string} path */
+						export function set_assets(path) {
+							assets = initial.assets = path;
+						}
+					`;
+			}
+
+			throw new Error(
+				`Cannot import ${id} into middleware code. Only the $app/paths module is available in middleware.`
+			);
+		}
+	};
+
+	await vite.build({
+		build: {
+			ssr: true,
+			modulePreload: false,
+			rollupOptions: {
+				input: {
+					middleware: middleware_entry_file
+				},
+				output: {
+					entryFileNames: 'middleware.js',
+					// TODO disallow assets? where should they go?
+					assetFileNames: `${kit.appDir}/immutable/assets/[name].[hash][extname]`,
+					inlineDynamicImports: true
+				}
+			},
+			outDir: `${out}/server`,
+			emptyOutDir: false,
+			minify: vite_config.build.minify
+		},
+		configFile: false,
+		define: vite_config.define,
+		publicDir: false,
+		plugins: [mw_virtual_modules],
+		resolve: {
+			alias: [
+				{ find: '$app/paths', replacement: `${runtime_directory}/app/paths` },
+				...get_config_aliases(kit)
+			]
+		}
+	});
+
+	await vite.build({
+		build: {
+			ssr: true,
+			modulePreload: false,
+			rollupOptions: {
+				input: {
+					middleware: `${runtime_directory}/server/call-middleware.js`
+				},
+				output: {
+					entryFileNames: 'call-middleware.js',
+					inlineDynamicImports: true
+				}
+			},
+			outDir: `${out}/server`,
+			emptyOutDir: false,
+			minify: vite_config.build.minify
+		},
+		configFile: false,
+		define: vite_config.define,
+		publicDir: false,
+		plugins: [mw_virtual_modules],
+		resolve: {
+			alias: [
+				{ find: '$app/paths', replacement: `${runtime_directory}/app/paths` },
+				...get_config_aliases(kit)
+			]
+		}
+	});
+}
diff --git a/src/exports/vite/build/build_server.js b/src/exports/vite/build/build_server.js
index 96ce9a7ed5fa21b9d526f5451114e40003e615f2..49ca69d292b66e8eb10c187e7eb38426d4edf77c 100644
--- a/src/exports/vite/build/build_server.js
+++ b/src/exports/vite/build/build_server.js
@@ -14,7 +14,15 @@ import { basename } from 'node:path';
  * @param {import('vite').Rollup.OutputAsset[] | null} css
  * @param {import('types').RecursiveRequired<import('types').ValidatedConfig['kit']['output']>} output_config
  */
-export function build_server_nodes(out, kit, manifest_data, server_manifest, client_manifest, css, output_config) {
+export function build_server_nodes(
+	out,
+	kit,
+	manifest_data,
+	server_manifest,
+	client_manifest,
+	css,
+	output_config
+) {
 	mkdirp(`${out}/server/nodes`);
 	mkdirp(`${out}/server/stylesheets`);
 
@@ -34,7 +42,9 @@ export function build_server_nodes(out, kit, manifest_data, server_manifest, cli
 		/** @type {Map<number, string>} */
 		const server_stylesheets = new Map();
 
-		const component_stylesheet_map = new Map(Object.values(server_manifest).map((file) => [file.src, file.css?.[0]]));
+		const component_stylesheet_map = new Map(
+			Object.values(server_manifest).map((file) => [file.src, file.css?.[0]])
+		);
 
 		manifest_data.nodes.forEach((node, i) => {
 			const server_stylesheet = component_stylesheet_map.get(node.component);
@@ -44,7 +54,8 @@ export function build_server_nodes(out, kit, manifest_data, server_manifest, cli
 		});
 
 		// ignore dynamically imported stylesheets since we can't inline those
-		css.filter(asset => client_stylesheets.has(asset.fileName))
+		css
+			.filter((asset) => client_stylesheets.has(asset.fileName))
 			.forEach((asset) => {
 				if (asset.source.length < kit.inlineStyleThreshold) {
 					// We know that the names for entry points are numbers.
@@ -111,7 +122,11 @@ export function build_server_nodes(out, kit, manifest_data, server_manifest, cli
 			exports.push(`export const server_id = ${s(node.server)};`);
 		}
 
-		if (client_manifest && (node.universal || node.component) && output_config.bundleStrategy === 'split') {
+		if (
+			client_manifest &&
+			(node.universal || node.component) &&
+			output_config.bundleStrategy === 'split'
+		) {
 			const entry = find_deps(
 				client_manifest,
 				`${normalizePath(kit.outDir)}/generated/client-optimized/nodes/${i}.js`,
diff --git a/src/exports/vite/dev/index.js b/src/exports/vite/dev/index.js
index d9f2476e6bc709e4e4902930ab6a9617a601354a..03dcceb28269482ee7caefaf45f7cc749ea6f2fc 100644
--- a/src/exports/vite/dev/index.js
+++ b/src/exports/vite/dev/index.js
@@ -1,7 +1,7 @@
 import fs from 'node:fs';
 import path from 'node:path';
 import process from 'node:process';
-import { URL } from 'node:url';
+import { fileURLToPath, URL } from 'node:url';
 import { AsyncLocalStorage } from 'node:async_hooks';
 import colors from 'kleur';
 import sirv from 'sirv';
@@ -519,7 +519,7 @@ export async function dev(vite, vite_config, svelte_config) {
 					read: (file) => createReadableStream(from_fs(file))
 				});
 
-				const request = await getRequest({
+				let request = await getRequest({
 					base,
 					request: req
 				});
@@ -546,6 +546,31 @@ export async function dev(vite, vite_config, svelte_config) {
 					return;
 				}
 
+				let middleware;
+				let middleware_result;
+				if (resolve_entry(hooks.middleware)) {
+					try {
+						({ middleware } = await vite.ssrLoadModule(hooks.middleware));
+					} catch (e) {
+						console.error(e);
+					}
+				}
+
+				const { call_middleware } = await vite.ssrLoadModule(
+					`${runtime_base}/server/call-middleware.js`,
+					{ fixStacktrace: true }
+				);
+
+				if (middleware) {
+					middleware_result = await call_middleware(request, middleware);
+					if (middleware_result instanceof Response) {
+						setResponse(res, middleware_result);
+						return;
+					} else {
+						request = middleware_result.request;
+					}
+				}
+
 				const rendered = await server.respond(request, {
 					getClientAddress: () => {
 						const { remoteAddress } = req.socket;
@@ -565,6 +590,8 @@ export async function dev(vite, vite_config, svelte_config) {
 					emulator
 				});
 
+				middleware_result?.add_response_headers?.(rendered);
+
 				if (rendered.status === 404) {
 					// @ts-expect-error
 					serve_static_middleware.handle(req, res, () => {
diff --git a/src/exports/vite/index.js b/src/exports/vite/index.js
index 4885d000ec1594440562da44148b4dfdcb7367a1..79e6e3b639a7609f1fad543dccb6ad55e53fe274 100644
--- a/src/exports/vite/index.js
+++ b/src/exports/vite/index.js
@@ -36,6 +36,7 @@ import {
 } from './module_ids.js';
 import { resolve_peer_dependency } from '../../utils/import.js';
 import { compact } from '../../utils/array.js';
+import { build_middleware } from './build/build_middleware.js';
 
 const cwd = process.cwd();
 
@@ -206,6 +207,7 @@ async function kit({ svelte_config }) {
 	/** @type {import('vite').UserConfig} */
 	let initial_config;
 
+	const middleware_file = resolve_entry(kit.files.hooks.middleware);
 	const service_worker_entry_file = resolve_entry(kit.files.serviceWorker);
 	const parsed_service_worker = path.parse(kit.files.serviceWorker);
 
@@ -769,9 +771,9 @@ Tips:
 		},
 
 		/**
-		 * Vite builds a single bundle. We need three bundles: client, server, and service worker.
+		 * Vite builds a single bundle. We need four bundles: client, server, service worker and middleware.
 		 * The user's package.json scripts will invoke the Vite CLI to execute the server build. We
-		 * then use this hook to kick off builds for the client and service worker.
+		 * then use this hook to kick off builds for the other ones.
 		 */
 		writeBundle: {
 			sequential: true,
@@ -1016,6 +1018,12 @@ Tips:
 					);
 				}
 
+				if (middleware_file) {
+					log.info('Building server middleware');
+
+					await build_middleware(out, kit, vite_config, runtime_directory, middleware_file);
+				}
+
 				// we need to defer this to closeBundle, so that adapters copy files
 				// created by other Vite plugins
 				finalise = async () => {
diff --git a/src/exports/vite/preview/index.js b/src/exports/vite/preview/index.js
index 481fa087eab7b7b73f79052c4bee768e6789eab7..13a91a6aeb75c6800f75cf6832c1a994dafc411f 100644
--- a/src/exports/vite/preview/index.js
+++ b/src/exports/vite/preview/index.js
@@ -43,6 +43,13 @@ export async function preview(vite, vite_config, svelte_config) {
 
 	const { manifest } = await import(pathToFileURL(join(dir, 'manifest.js')).href);
 
+	const { middleware } = await import(pathToFileURL(join(dir, 'middleware.js')).href).catch(
+		() => ({})
+	);
+	const { call_middleware } = await import(
+		pathToFileURL(join(dir, 'middleware-preview.js')).href
+	).catch(() => ({}));
+
 	set_assets(assets);
 
 	const server = new Server(manifest);
@@ -110,6 +117,40 @@ export async function preview(vite, vite_config, svelte_config) {
 			scoped(base, mutable(join(svelte_config.kit.outDir, 'output/prerendered/dependencies')))
 		);
 
+		// middleware
+		if (middleware) {
+			vite.middlewares.use(async (req, res, next) => {
+				const host = req.headers[':authority'] || req.headers.host;
+
+				const request = await getRequest({
+					base: `${protocol}://${host}`,
+					request: req
+				});
+
+				const result = await call_middleware(request, middleware);
+
+				if (result instanceof Response) {
+					setResponse(res, result);
+				}
+
+				for (const [key, value] of result.request.headers.entries()) {
+					req.headers[key] = value;
+				}
+
+				const url = new URL(result.request.url);
+				req.url = url.pathname + url.search;
+
+				const response = new Response();
+				result.add_response_headers(response);
+
+				for (const [key, value] of result.request.headers.entries()) {
+					res.setHeader(key, value);
+				}
+
+				next();
+			});
+		}
+
 		// prerendered pages (we can't just use sirv because we need to
 		// preserve the correct trailingSlash behaviour)
 		vite.middlewares.use(
diff --git a/src/runtime/app/forms.js b/src/runtime/app/forms.js
index 4ed8f64c7e2ed9ce99267d90bf348433f2116f87..3715d8fc4cd950984ac8136dbdece02ba1acbf3e 100644
--- a/src/runtime/app/forms.js
+++ b/src/runtime/app/forms.js
@@ -205,7 +205,7 @@ export function enhance(form_element, submit = () => {}) {
 			result = { type: 'error', error };
 		}
 
-		callback({
+		await callback({
 			action,
 			formData: form_data,
 			formElement: form_element,
diff --git a/src/runtime/server/call-middleware.js b/src/runtime/server/call-middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..8652d5cb2af47aa5c810e0a373d945e07d530086
--- /dev/null
+++ b/src/runtime/server/call-middleware.js
@@ -0,0 +1,95 @@
+import { add_cookies_to_headers, get_cookies } from './cookie.js';
+import { add_resolution_prefix } from '../pathname.js';
+import { normalize_url } from './utils.js';
+
+/**
+ * @param {Request} request
+ * @param {import('@sveltejs/kit').Middleware} middleware
+ * @returns {ReturnType<import('@sveltejs/kit').CallMiddleware>}
+ */
+export async function call_middleware(request, middleware) {
+	const { cookies, new_cookies } = get_cookies(request, new URL(request.url), 'never');
+
+	let request_headers_called = false;
+	let request_headers = new Headers(request.headers);
+	/** @param {Record<string, string>} headers */
+	const setRequestHeaders = (headers) => {
+		for (const key in headers) {
+			const lower = key.toLowerCase();
+			const value = headers[key];
+
+			if (lower === 'set-cookie') {
+				throw new Error('Cannot set cookies on the request header');
+			} else {
+				request_headers_called = true;
+				request_headers.set(key, value);
+			}
+		}
+	};
+
+	let response_headers = new Headers();
+	/** @param {Record<string, string>} headers */
+	const setResponseHeaders = (headers) => {
+		for (const key in headers) {
+			const lower = key.toLowerCase();
+			const value = headers[key];
+
+			if (lower === 'set-cookie') {
+				throw new Error(
+					'Use `cookies.set(name, value, options)` instead of `setResponseHeaders` to set cookies'
+				);
+			} else {
+				response_headers.set(key, value);
+			}
+		}
+	};
+
+	/** @param {string} pathname */
+	const reroute = (pathname) => {
+		return pathname; // TODO think about making this a class object
+	};
+
+	const { url, is_route_resolution_request } = normalize_url(new URL(request.url));
+
+	const result = await middleware({
+		request,
+		url,
+		setRequestHeaders,
+		setResponseHeaders,
+		cookies,
+		reroute
+	});
+
+	add_cookies_to_headers(response_headers, Object.values(new_cookies));
+
+	const add_response_headers = /** @param {Response} response */ (response) => {
+		for (const [key, value] of response_headers) {
+			response.headers.set(key, value);
+		}
+	};
+
+	if (result instanceof Response) {
+		return result;
+	}
+
+	if (typeof result === 'string' || request_headers_called) {
+		const url = new URL(
+			typeof result === 'string'
+				? is_route_resolution_request
+					? add_resolution_prefix(result)
+					: result
+				: request.url,
+			request.url
+		);
+
+		request = new Request(url, { headers: request_headers });
+	}
+
+	return {
+		request,
+		request_headers,
+		did_reroute: typeof result === 'string',
+		response_headers,
+		add_response_headers
+	};
+}
diff --git a/src/runtime/server/page/server_routing.js b/src/runtime/server/page/server_routing.js
index 1caf4cbbb4b2dc7a6df80864c16080052ebcb4b0..8f66fb8eb65dac414736fb27f6c9b09bc0e65787 100644
--- a/src/runtime/server/page/server_routing.js
+++ b/src/runtime/server/page/server_routing.js
@@ -1,4 +1,4 @@
-import { base, assets } from '__sveltekit/paths';
+import { base, assets, relative } from '__sveltekit/paths';
 import { text } from '../../../exports/index.js';
 import { s } from '../../../utils/misc.js';
 import { exec } from '../../../utils/routing.js';
@@ -47,6 +47,10 @@ function create_client_import(import_path, url) {
 		return `import('${assets}/${import_path}')`;
 	}
 
+	if (!relative) {
+		return `import('${base}/${import_path}')`;
+	}
+
 	// Else we make them relative to the server-side route resolution request
 	// to support IPFS, the internet archive, etc.
 	let path = get_relative_path(url.pathname, `${base}/${import_path}`);
diff --git a/src/runtime/server/respond.js b/src/runtime/server/respond.js
index 429d523c371547c38187c39196551c3cb763060d..b9f7a95b5d857c8f6efe2607b0a98653cd49a386 100644
--- a/src/runtime/server/respond.js
+++ b/src/runtime/server/respond.js
@@ -5,7 +5,12 @@ import { render_page } from './page/index.js';
 import { render_response } from './page/render.js';
 import { respond_with_error } from './page/respond_with_error.js';
 import { is_form_content_type } from '../../utils/http.js';
-import { handle_fatal_error, method_not_allowed, redirect_response } from './utils.js';
+import {
+	handle_fatal_error,
+	method_not_allowed,
+	normalize_url,
+	redirect_response
+} from './utils.js';
 import { decode_pathname, decode_params, disable_search, normalize_path } from '../../utils/url.js';
 import { exec } from '../../utils/routing.js';
 import { redirect_json_response, render_data } from './data/index.js';
@@ -87,29 +92,8 @@ export async function respond(request, options, manifest, state) {
 		return text('Not found', { status: 404 });
 	}
 
-	/** @type {boolean[] | undefined} */
-	let invalidated_data_nodes;
-
-	/**
-	 * If the request is for a route resolution, first modify the URL, then continue as normal
-	 * for path resolution, then return the route object as a JS file.
-	 */
-	const is_route_resolution_request = has_resolution_prefix(url.pathname);
-	const is_data_request = has_data_suffix(url.pathname);
-
-	if (is_route_resolution_request) {
-		url.pathname = strip_resolution_prefix(url.pathname);
-	} else if (is_data_request) {
-		url.pathname =
-			strip_data_suffix(url.pathname) +
-				(url.searchParams.get(TRAILING_SLASH_PARAM) === '1' ? '/' : '') || '/';
-		url.searchParams.delete(TRAILING_SLASH_PARAM);
-		invalidated_data_nodes = url.searchParams
-			.get(INVALIDATED_PARAM)
-			?.split('')
-			.map((node) => node === '1');
-		url.searchParams.delete(INVALIDATED_PARAM);
-	}
+	const { is_route_resolution_request, is_data_request, invalidated_data_nodes } =
+		normalize_url(url);
 
 	let resolved_path;
 
diff --git a/src/runtime/server/utils.js b/src/runtime/server/utils.js
index 473804cf91831e87c9f21eb55689ec7e14da36f8..08463a700dc9d9e9cb983ad5539e2d03e74e8db9 100644
--- a/src/runtime/server/utils.js
+++ b/src/runtime/server/utils.js
@@ -6,6 +6,13 @@ import { HttpError } from '../control.js';
 import { fix_stack_trace } from '../shared-server.js';
 import { ENDPOINT_METHODS } from '../../constants.js';
 import { escape_html } from '../../utils/escape.js';
+import {
+	has_resolution_prefix,
+	has_data_suffix,
+	strip_resolution_prefix,
+	strip_data_suffix
+} from '../pathname.js';
+import { TRAILING_SLASH_PARAM, INVALIDATED_PARAM } from '../shared.js';
 
 /** @param {any} body */
 export function is_pojo(body) {
@@ -163,3 +170,39 @@ export function stringify_uses(node) {
 
 	return `"uses":{${uses.join(',')}}`;
 }
+
+/**
+ * Strips route resolution/data request from the URL pathname (incoming URL is manipulated) and return info about the URL
+ * @param {URL} url
+ */
+export function normalize_url(url) {
+	const is_route_resolution_request = has_resolution_prefix(url.pathname);
+	const is_data_request = has_data_suffix(url.pathname);
+	/** @type {boolean[] | undefined} */
+	let invalidated_data_nodes;
+
+	if (is_route_resolution_request) {
+		url.pathname = strip_resolution_prefix(url.pathname);
+	} else if (is_data_request) {
+		url.pathname =
+			strip_data_suffix(url.pathname) +
+				(url.searchParams.get(TRAILING_SLASH_PARAM) === '1' ? '/' : '') || '/';
+		url.searchParams.delete(TRAILING_SLASH_PARAM);
+		invalidated_data_nodes = url.searchParams
+			.get(INVALIDATED_PARAM)
+			?.split('')
+			.map((node) => node === '1');
+		url.searchParams.delete(INVALIDATED_PARAM);
+	}
+
+	return {
+		/**
+		 * If the request is for a route resolution, first modify the URL, then continue as normal
+		 * for path resolution, then return the route object as a JS file.
+		 */
+		is_route_resolution_request,
+		is_data_request,
+		invalidated_data_nodes,
+		url
+	};
+}
diff --git a/src/utils/features.js b/src/utils/features.js
index 4a8530d22bbb89ecf276ae1f7ba48522cb0f6111..7744d0ff7cdfebffcdba98edb47e3e9b75b141e4 100644
--- a/src/utils/features.js
+++ b/src/utils/features.js
@@ -22,3 +22,16 @@ export function check_feature(route_id, config, feature, adapter) {
 		}
 	}
 }
+
+/**
+ * @param {import('@sveltejs/kit').Adapter | undefined} adapter
+ */
+export function check_middleware_feature(adapter) {
+	if (!adapter) return;
+
+	if (!adapter.supports?.middleware?.()) {
+		throw new Error(
+			`Cannot use middleware when using ${adapter.name}. Please ensure that your adapter is up to date and supports this feature.`
+		);
+	}
+}
diff --git a/src/version.js b/src/version.js
index 4ec4da11a14d6c4b0455ebf114391bfe530c6ac4..616a96c7d393ee9e4f22dc5f02df49e582e4960b 100644
--- a/src/version.js
+++ b/src/version.js
@@ -1,4 +1,4 @@
 // generated during release, do not modify
 
 /** @type {string} */
-export const VERSION = '2.17.0';
+export const VERSION = '2.17.1';
