diff --git a/files/middleware.js b/files/middleware.js
new file mode 100644
index 0000000000000000000000000000000000000000..977a91a222f6347100ef83e706e3998f3280ab88
--- /dev/null
+++ b/files/middleware.js
@@ -0,0 +1,24 @@
+// src/middleware.js
+import { normalizeUrl } from "@sveltejs/kit";
+import { onRequest as user_middleware } from "MIDDLEWARE";
+async function onRequest(context) {
+  const { url, neededNormalization, denormalize } = normalizeUrl(context.request.url);
+  if (neededNormalization) {
+    const request = new Request(url.href, context.request);
+    const next = (request2, options) => {
+      if (request2) {
+        request2 = new Request(
+          denormalize(typeof request2 === "string" ? request2 : request2.url),
+          options ?? (request2 instanceof Request ? request2 : context.request)
+        );
+      }
+      return context.next(request2, options);
+    };
+    return user_middleware({ ...context, request, next });
+  } else {
+    return user_middleware(context);
+  }
+}
+export {
+  onRequest
+};
diff --git a/files/worker.js b/files/worker.js
index 3e036257859b6a905255c0879fdf8d2a6c0bc5a3..726d3c5e7ea86ad9ca3ccae6aa422b4089e89741 100644
--- a/files/worker.js
+++ b/files/worker.js
@@ -1,6 +1,7 @@
 // src/worker.js
 import { Server } from "SERVER";
 import { manifest, prerendered, base_path } from "MANIFEST";
+import { onRequest } from "MIDDLEWARE";
 
 // ../../node_modules/.pnpm/worktop@0.8.0-next.18/node_modules/worktop/cache/index.mjs
 async function e(e3, t2) {
@@ -41,46 +42,62 @@ var app_path = `/${manifest.appPath}`;
 var immutable = `${app_path}/immutable/`;
 var version_file = `${app_path}/version.json`;
 var worker = {
-  async fetch(req, env, context) {
+  async fetch(request, env, context) {
     await server.init({ env });
-    let pragma = req.headers.get("cache-control") || "";
-    let res = !pragma.includes("no-cache") && await r2(req);
-    if (res) return res;
-    let { pathname, search } = new URL(req.url);
-    try {
-      pathname = decodeURIComponent(pathname);
-    } catch {
-    }
-    const stripped_pathname = pathname.replace(/\/$/, "");
-    let is_static_asset = false;
-    const filename = stripped_pathname.slice(base_path.length + 1);
-    if (filename) {
-      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
-    }
-    let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
-    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
-      res = await env.ASSETS.fetch(req);
-    } else if (location && prerendered.has(location)) {
-      if (search) location += search;
-      res = new Response("", {
-        status: 308,
-        headers: {
-          location
-        }
-      });
-    } else {
-      res = await server.respond(req, {
-        // @ts-ignore
-        platform: { env, context, caches, cf: req.cf },
-        getClientAddress() {
-          return req.headers.get("cf-connecting-ip");
-        }
-      });
-    }
-    pragma = res.headers.get("cache-control") || "";
-    return pragma && res.status < 400 ? c(req, res, context) : res;
+    let pragma = request.headers.get("cache-control") || "";
+    let response = !pragma.includes("no-cache") && await r2(request);
+    if (response) return response;
+    const next = async (input, init) => {
+      let req;
+      if (!input && !init) {
+        req = request;
+      } else if (input instanceof Request) {
+        req = input;
+      } else {
+        req = new Request(input, init);
+      }
+      return inner_fetch(req, env, context);
+    };
+    response = await onRequest({ ...context, request, env, next });
+    pragma = response.headers.get("cache-control") || "";
+    return pragma && response.status < 400 ? c(request, response, context) : response;
   }
 };
+async function inner_fetch(request, env, context) {
+  let { pathname, search } = new URL(request.url);
+  try {
+    pathname = decodeURIComponent(pathname);
+  } catch {
+  }
+  const stripped_pathname = pathname.replace(/\/$/, "");
+  let is_static_asset = false;
+  const filename = stripped_pathname.slice(base_path.length + 1);
+  if (filename) {
+    is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
+  }
+  let response;
+  let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
+  if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
+    response = await env.ASSETS.fetch(request);
+  } else if (location && prerendered.has(location)) {
+    if (search) location += search;
+    response = new Response("", {
+      status: 308,
+      headers: {
+        location
+      }
+    });
+  } else {
+    response = await server.respond(request, {
+      // @ts-ignore
+      platform: { env, context, caches, cf: request.cf },
+      getClientAddress() {
+        return request.headers.get("cf-connecting-ip");
+      }
+    });
+  }
+  return response;
+}
 var worker_default = worker;
 export {
   worker_default as default
diff --git a/index.js b/index.js
index e00eb988992933521de8d47dec641d9bb3afa370..6bc24790684b17bea76e5f944252447f40d1fb35 100644
--- a/index.js
+++ b/index.js
@@ -2,6 +2,19 @@ import { existsSync, writeFileSync } from 'node:fs';
 import * as path from 'node:path';
 import { fileURLToPath } from 'node:url';
 import { getPlatformProxy } from 'wrangler';
+// TODO 3.0: switch to named imports, right now we're doing `import * as ..` to avoid having to bump the peer dependency on Kit
+import * as kit from '@sveltejs/kit';
+import * as node_kit from '@sveltejs/kit/node';
+
+const [major, minor] = kit.VERSION.split('.').map(Number);
+const can_use_middleware = major > 2 || (major === 2 && minor > 17);
+
+/** @type {string | null} */
+let middleware_path = can_use_middleware ? 'src/cloudflare-middleware.js' : null;
+if (middleware_path && !existsSync(middleware_path)) {
+	middleware_path = 'src/cloudflare-middleware.ts';
+	if (!existsSync(middleware_path)) middleware_path = null;
+}
 
 /** @type {import('./index.js').default} */
 export default function (options = {}) {
@@ -45,6 +58,19 @@ export default function (options = {}) {
 					`export const base_path = ${JSON.stringify(builder.config.kit.paths.base)};\n`
 			);
 
+			if (middleware_path) {
+				builder.copy(`${files}/middleware.js`, `${tmp}/middleware.js`, {
+					replace: {
+						MIDDLEWARE: `${path.posix.relative(tmp, builder.getServerDirectory())}/adapter/cloudflare-middleware.js`
+					}
+				});
+			} else {
+				writeFileSync(
+					`${tmp}/middleware.js`,
+					'export function onRequest({ next }) { return next() }'
+				);
+			}
+
 			writeFileSync(
 				`${dest}/_routes.json`,
 				JSON.stringify(get_routes_json(builder, written_files, options.routes ?? {}), null, '\t')
@@ -63,11 +89,13 @@ export default function (options = {}) {
 			builder.copy(`${files}/worker.js`, `${dest}/_worker.js`, {
 				replace: {
 					SERVER: `${relativePath}/index.js`,
-					MANIFEST: `${path.posix.relative(dest, tmp)}/manifest.js`
+					MANIFEST: `${path.posix.relative(dest, tmp)}/manifest.js`,
+					MIDDLEWARE: `${path.posix.relative(dest, tmp)}/middleware.js`
 				}
 			});
 		},
-		emulate() {
+
+		emulate(opts) {
 			// we want to invoke `getPlatformProxy` only once, but await it only when it is accessed.
 			// If we would await it here, it would hang indefinitely because the platform proxy only resolves once a request happens
 			const get_emulated = async () => {
@@ -98,9 +126,70 @@ export default function (options = {}) {
 				platform: async ({ prerender }) => {
 					emulated ??= await get_emulated();
 					return prerender ? emulated.prerender_platform : emulated.platform;
+				},
+				beforeRequest: async (req, res, next) => {
+					emulated ??= await get_emulated();
+					const middleware = await opts.importEntryPoint('cloudflare-middleware');
+
+					const { url, denormalize } = kit.normalizeUrl(req.url);
+
+					const request = new Request(url, {
+						headers: node_kit.getRequestHeaders(req),
+						method: req.method,
+						body:
+							// We omit the body here because it would consume the stream
+							req.method === 'GET' || req.method === 'HEAD' || !req.headers['content-type']
+								? undefined
+								: 'Cannot read body in dev mode'
+					});
+					// @ts-expect-error slight type mismatch which seems harmless
+					request.cf = emulated.platform.cf;
+
+					// Cloudflare allows you to modify the response object after calling next().
+					// This isn't replicable using Vite or Polka middleware, so we approximate it.
+					const fake_response = new Response();
+
+					const response = await middleware.onRequest(
+						/** @type {Partial<import('@cloudflare/workers-types').EventContext<any, any, any>>} */ ({
+							// eslint-disable-next-line object-shorthand
+							request: /** @type {any} */ (request), // requires a fetcher property which we don't have
+							env: /** @type {any} */ (emulated.platform).env, // does exist, see above
+							...emulated.platform.context,
+							next: (input, init) => {
+								// More any casts because of annoying CF types
+								const request =
+									input instanceof Request
+										? input
+										: input && new Request(/** @type {any} */ (input), /** @type {any} */ (init));
+
+								if (request) {
+									const url = denormalize(request.url);
+									req.url = url.pathname + url.search;
+									for (const [key, value] of request.headers) {
+										req.headers[key] = value;
+									}
+								}
+
+								return Promise.resolve(/** @type {any} */ (fake_response));
+							}
+						})
+					);
+
+					if (response instanceof Response && response !== fake_response) {
+						// We assume that middleware bails out when returning a custom response
+						return node_kit.setResponse(res, response);
+					} else {
+						for (const header of fake_response.headers) {
+							res.setHeader(header[0], header[1]);
+						}
+
+						return next();
+					}
 				}
 			};
-		}
+		},
+
+		additionalEntryPoints: { 'cloudflare-middleware': middleware_path }
 	};
 }
 
@@ -127,7 +216,7 @@ function get_routes_json(builder, assets, { include = ['/*'], exclude = ['<all>'
 		.flatMap((rule) => (rule === '<all>' ? ['<build>', '<files>', '<prerendered>'] : rule))
 		.flatMap((rule) => {
 			if (rule === '<build>') {
-				return `/${builder.getAppPath()}/*`;
+				return [`/${builder.getAppPath()}/immutable/*`, `/${builder.getAppPath()}/version.json`];
 			}
 
 			if (rule === '<files>') {
