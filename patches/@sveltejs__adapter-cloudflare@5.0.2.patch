diff --git a/files/worker.js b/files/worker.js
index 3e036257859b6a905255c0879fdf8d2a6c0bc5a3..4a9e6cec28bedd87be71b467c1a4a84290bdeb55 100644
--- a/files/worker.js
+++ b/files/worker.js
@@ -1,6 +1,8 @@
 // src/worker.js
 import { Server } from "SERVER";
 import { manifest, prerendered, base_path } from "MANIFEST";
+import { middleware as user_middleware } from "MIDDLEWARE";
+import { call_middleware } from "CALL_MIDDLEWARE";
 
 // ../../node_modules/.pnpm/worktop@0.8.0-next.18/node_modules/worktop/cache/index.mjs
 async function e(e3, t2) {
@@ -10,9 +12,21 @@ async function e(e3, t2) {
   return n2 && r3 && (r3 = new Response(null, r3)), r3;
 }
 function t(e3, t2, n2, o2) {
-  return ("string" == typeof t2 || "GET" === t2.method) && r(n2) && (n2.headers.has("Set-Cookie") && (n2 = new Response(n2.body, n2)).headers.append("Cache-Control", "private=Set-Cookie"), o2.waitUntil(e3.put(t2, n2.clone()))), n2;
+  return (
+    ("string" == typeof t2 || "GET" === t2.method) &&
+      r(n2) &&
+      (n2.headers.has("Set-Cookie") &&
+        (n2 = new Response(n2.body, n2)).headers.append(
+          "Cache-Control",
+          "private=Set-Cookie"
+        ),
+      o2.waitUntil(e3.put(t2, n2.clone()))),
+    n2
+  );
 }
-var n = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
+var n = /* @__PURE__ */ new Set([
+  200, 203, 204, 300, 301, 404, 405, 410, 414, 501,
+]);
 function r(e3) {
   if (!n.has(e3.status)) return false;
   if (~(e3.headers.get("Vary") || "").indexOf("*")) return false;
@@ -20,7 +34,7 @@ function r(e3) {
   return !/(private|no-cache|no-store)/i.test(t2);
 }
 function o(n2) {
-  return async function(r3, o2) {
+  return async function (r3, o2) {
     let a = await e(n2, r3);
     if (a) return a;
     o2.defer((e3) => {
@@ -43,30 +57,41 @@ var version_file = `${app_path}/version.json`;
 var worker = {
   async fetch(req, env, context) {
     await server.init({ env });
+    const mw_response = await call_middleware(req, user_middleware);
+    if (mw_response instanceof Response) return mw_response;
+    req = mw_response.request;
     let pragma = req.headers.get("cache-control") || "";
-    let res = !pragma.includes("no-cache") && await r2(req);
+    let res = !pragma.includes("no-cache") && (await r2(req));
     if (res) return res;
     let { pathname, search } = new URL(req.url);
     try {
       pathname = decodeURIComponent(pathname);
-    } catch {
-    }
+    } catch {}
     const stripped_pathname = pathname.replace(/\/$/, "");
     let is_static_asset = false;
     const filename = stripped_pathname.slice(base_path.length + 1);
     if (filename) {
-      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
+      is_static_asset =
+        manifest.assets.has(filename) ||
+        manifest.assets.has(filename + "/index.html") ||
+        filename in manifest._.server_assets ||
+        filename + "/index.html" in manifest._.server_assets;
     }
     let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
-    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
+    if (
+      is_static_asset ||
+      prerendered.has(pathname) ||
+      pathname === version_file ||
+      pathname.startsWith(immutable)
+    ) {
       res = await env.ASSETS.fetch(req);
     } else if (location && prerendered.has(location)) {
       if (search) location += search;
       res = new Response("", {
         status: 308,
         headers: {
-          location
-        }
+          location,
+        },
       });
     } else {
       res = await server.respond(req, {
@@ -74,14 +99,13 @@ var worker = {
         platform: { env, context, caches, cf: req.cf },
         getClientAddress() {
           return req.headers.get("cf-connecting-ip");
-        }
+        },
       });
     }
+    mw_response.add_response_headers(res);
     pragma = res.headers.get("cache-control") || "";
     return pragma && res.status < 400 ? c(req, res, context) : res;
-  }
+  },
 };
 var worker_default = worker;
-export {
-  worker_default as default
-};
+export { worker_default as default };
diff --git a/index.js b/index.js
index e00eb988992933521de8d47dec641d9bb3afa370..c27afe4e36cccdbed24f51c8e8cb0f1cf6f0746a 100644
--- a/index.js
+++ b/index.js
@@ -1,174 +1,244 @@
-import { existsSync, writeFileSync } from 'node:fs';
-import * as path from 'node:path';
-import { fileURLToPath } from 'node:url';
-import { getPlatformProxy } from 'wrangler';
+import { existsSync, writeFileSync } from "node:fs";
+import * as path from "node:path";
+import { fileURLToPath } from "node:url";
+import { getPlatformProxy } from "wrangler";
 
 /** @type {import('./index.js').default} */
 export default function (options = {}) {
-	return {
-		name: '@sveltejs/adapter-cloudflare',
-		async adapt(builder) {
-			if (existsSync('_routes.json')) {
-				throw new Error(
-					'Cloudflare routes should be configured in svelte.config.js rather than _routes.json'
-				);
-			}
-
-			const files = fileURLToPath(new URL('./files', import.meta.url).href);
-			const dest = builder.getBuildDirectory('cloudflare');
-			const tmp = builder.getBuildDirectory('cloudflare-tmp');
-
-			builder.rimraf(dest);
-			builder.rimraf(tmp);
-
-			builder.mkdirp(dest);
-			builder.mkdirp(tmp);
-
-			// generate plaintext 404.html first which can then be overridden by prerendering, if the user defined such a page
-			const fallback = path.join(dest, '404.html');
-			if (options.fallback === 'spa') {
-				await builder.generateFallback(fallback);
-			} else {
-				writeFileSync(fallback, 'Not Found');
-			}
-
-			const dest_dir = `${dest}${builder.config.kit.paths.base}`;
-			const written_files = builder.writeClient(dest_dir);
-			builder.writePrerendered(dest_dir);
-
-			const relativePath = path.posix.relative(dest, builder.getServerDirectory());
-
-			writeFileSync(
-				`${tmp}/manifest.js`,
-				`export const manifest = ${builder.generateManifest({ relativePath })};\n\n` +
-					`export const prerendered = new Set(${JSON.stringify(builder.prerendered.paths)});\n\n` +
-					`export const base_path = ${JSON.stringify(builder.config.kit.paths.base)};\n`
-			);
-
-			writeFileSync(
-				`${dest}/_routes.json`,
-				JSON.stringify(get_routes_json(builder, written_files, options.routes ?? {}), null, '\t')
-			);
-
-			writeFileSync(`${dest}/_headers`, generate_headers(builder.getAppPath()), { flag: 'a' });
-
-			if (builder.prerendered.redirects.size > 0) {
-				writeFileSync(`${dest}/_redirects`, generate_redirects(builder.prerendered.redirects), {
-					flag: 'a'
-				});
-			}
-
-			writeFileSync(`${dest}/.assetsignore`, generate_assetsignore(), { flag: 'a' });
-
-			builder.copy(`${files}/worker.js`, `${dest}/_worker.js`, {
-				replace: {
-					SERVER: `${relativePath}/index.js`,
-					MANIFEST: `${path.posix.relative(dest, tmp)}/manifest.js`
-				}
-			});
-		},
-		emulate() {
-			// we want to invoke `getPlatformProxy` only once, but await it only when it is accessed.
-			// If we would await it here, it would hang indefinitely because the platform proxy only resolves once a request happens
-			const get_emulated = async () => {
-				const proxy = await getPlatformProxy(options.platformProxy);
-				const platform = /** @type {App.Platform} */ ({
-					env: proxy.env,
-					context: proxy.ctx,
-					caches: proxy.caches,
-					cf: proxy.cf
-				});
-				/** @type {Record<string, any>} */
-				const env = {};
-				const prerender_platform = /** @type {App.Platform} */ (/** @type {unknown} */ ({ env }));
-				for (const key in proxy.env) {
-					Object.defineProperty(env, key, {
-						get: () => {
-							throw new Error(`Cannot access platform.env.${key} in a prerenderable route`);
-						}
-					});
-				}
-				return { platform, prerender_platform };
-			};
-
-			/** @type {{ platform: App.Platform, prerender_platform: App.Platform }} */
-			let emulated;
-
-			return {
-				platform: async ({ prerender }) => {
-					emulated ??= await get_emulated();
-					return prerender ? emulated.prerender_platform : emulated.platform;
-				}
-			};
-		}
-	};
+  return {
+    name: "@sveltejs/adapter-cloudflare",
+    async adapt(builder) {
+      if (existsSync("_routes.json")) {
+        throw new Error(
+          "Cloudflare routes should be configured in svelte.config.js rather than _routes.json"
+        );
+      }
+
+      const files = fileURLToPath(new URL("./files", import.meta.url).href);
+      const dest = builder.getBuildDirectory("cloudflare");
+      const tmp = builder.getBuildDirectory("cloudflare-tmp");
+
+      builder.rimraf(dest);
+      builder.rimraf(tmp);
+
+      builder.mkdirp(dest);
+      builder.mkdirp(tmp);
+
+      // generate plaintext 404.html first which can then be overridden by prerendering, if the user defined such a page
+      const fallback = path.join(dest, "404.html");
+      if (options.fallback === "spa") {
+        await builder.generateFallback(fallback);
+      } else {
+        writeFileSync(fallback, "Not Found");
+      }
+
+      const dest_dir = `${dest}${builder.config.kit.paths.base}`;
+      const written_files = builder.writeClient(dest_dir);
+      builder.writePrerendered(dest_dir);
+
+      const has_middleware = existsSync(
+        `${builder.getServerDirectory()}/middleware.js`
+      );
+      const relativePath = path.posix.relative(
+        dest,
+        builder.getServerDirectory()
+      );
+
+      writeFileSync(
+        `${tmp}/manifest.js`,
+        `export const manifest = ${builder.generateManifest({
+          relativePath,
+        })};\n\n` +
+          `export const prerendered = new Set(${JSON.stringify(
+            builder.prerendered.paths
+          )});\n\n` +
+          `export const base_path = ${JSON.stringify(
+            builder.config.kit.paths.base
+          )};\n` +
+          `export const app_dir = ${JSON.stringify(
+            builder.config.kit.appDir
+          )};\n`
+      );
+
+      writeFileSync(
+        `${dest}/_routes.json`,
+        JSON.stringify(
+          get_routes_json(
+            builder,
+            written_files,
+            !has_middleware,
+            options.routes ?? {}
+          ),
+          null,
+          "\t"
+        )
+      );
+
+      writeFileSync(
+        `${dest}/_headers`,
+        generate_headers(builder.getAppPath()),
+        { flag: "a" }
+      );
+
+      if (builder.prerendered.redirects.size > 0) {
+        writeFileSync(
+          `${dest}/_redirects`,
+          generate_redirects(builder.prerendered.redirects),
+          {
+            flag: "a",
+          }
+        );
+      }
+
+      writeFileSync(`${dest}/.assetsignore`, generate_assetsignore(), {
+        flag: "a",
+      });
+
+      if (!has_middleware) {
+        builder.copy(
+          `${files}/noop-middleware.js`,
+          `${builder.getServerDirectory()}/middleware.js`
+        );
+        builder.copy(
+          `${files}/noop-middleware.js`,
+          `${builder.getServerDirectory()}/call-middleware.js`
+        );
+      }
+
+      builder.copy(`${files}/worker.js`, `${dest}/_worker.js`, {
+        replace: {
+          SERVER: `${relativePath}/index.js`,
+          MANIFEST: `${path.posix.relative(dest, tmp)}/manifest.js`,
+          MIDDLEWARE: `${relativePath}/middleware.js`,
+          CALL_MIDDLEWARE: `${relativePath}/call-middleware.js`,
+        },
+      });
+    },
+
+    emulate() {
+      // we want to invoke `getPlatformProxy` only once, but await it only when it is accessed.
+      // If we would await it here, it would hang indefinitely because the platform proxy only resolves once a request happens
+      const get_emulated = async () => {
+        const proxy = await getPlatformProxy(options.platformProxy);
+        const platform = /** @type {App.Platform} */ ({
+          env: proxy.env,
+          context: proxy.ctx,
+          caches: proxy.caches,
+          cf: proxy.cf,
+        });
+        /** @type {Record<string, any>} */
+        const env = {};
+        const prerender_platform = /** @type {App.Platform} */ (
+          /** @type {unknown} */ ({ env })
+        );
+        for (const key in proxy.env) {
+          Object.defineProperty(env, key, {
+            get: () => {
+              throw new Error(
+                `Cannot access platform.env.${key} in a prerenderable route`
+              );
+            },
+          });
+        }
+        return { platform, prerender_platform };
+      };
+
+      /** @type {{ platform: App.Platform, prerender_platform: App.Platform }} */
+      let emulated;
+
+      return {
+        platform: async ({ prerender }) => {
+          emulated ??= await get_emulated();
+          return prerender ? emulated.prerender_platform : emulated.platform;
+        },
+      };
+    },
+
+    supports: {
+      middleware: () => true,
+    },
+  };
 }
 
 /**
  * @param {import('@sveltejs/kit').Builder} builder
  * @param {string[]} assets
+ * @param {boolean} exclude_prerendered
  * @param {import('./index.js').AdapterOptions['routes']} routes
  * @returns {import('./index.js').RoutesJSONSpec}
  */
-function get_routes_json(builder, assets, { include = ['/*'], exclude = ['<all>'] }) {
-	if (!Array.isArray(include) || !Array.isArray(exclude)) {
-		throw new Error('routes.include and routes.exclude must be arrays');
-	}
-
-	if (include.length === 0) {
-		throw new Error('routes.include must contain at least one route');
-	}
-
-	if (include.length > 100) {
-		throw new Error('routes.include must contain 100 or fewer routes');
-	}
-
-	exclude = exclude
-		.flatMap((rule) => (rule === '<all>' ? ['<build>', '<files>', '<prerendered>'] : rule))
-		.flatMap((rule) => {
-			if (rule === '<build>') {
-				return `/${builder.getAppPath()}/*`;
-			}
-
-			if (rule === '<files>') {
-				return assets
-					.filter(
-						(file) =>
-							!(
-								file.startsWith(`${builder.config.kit.appDir}/`) ||
-								file === '_headers' ||
-								file === '_redirects'
-							)
-					)
-					.map((file) => `${builder.config.kit.paths.base}/${file}`);
-			}
-
-			if (rule === '<prerendered>') {
-				return builder.prerendered.paths;
-			}
-
-			return rule;
-		});
-
-	const excess = include.length + exclude.length - 100;
-	if (excess > 0) {
-		const message = `Function includes/excludes exceeds _routes.json limits (see https://developers.cloudflare.com/pages/platform/functions/routing/#limits). Dropping ${excess} exclude rules — this will cause unnecessary function invocations.`;
-		builder.log.warn(message);
-
-		exclude.length -= excess;
-	}
-
-	return {
-		version: 1,
-		description: 'Generated by @sveltejs/adapter-cloudflare',
-		include,
-		exclude
-	};
+function get_routes_json(
+  builder,
+  assets,
+  exclude_prerendered,
+  {
+    include = ["/*"],
+    exclude = exclude_prerendered ? ["<all>"] : ["<build>", "<files>"],
+  }
+) {
+  if (!Array.isArray(include) || !Array.isArray(exclude)) {
+    throw new Error("routes.include and routes.exclude must be arrays");
+  }
+
+  if (include.length === 0) {
+    throw new Error("routes.include must contain at least one route");
+  }
+
+  if (include.length > 100) {
+    throw new Error("routes.include must contain 100 or fewer routes");
+  }
+
+  exclude = exclude
+    .flatMap((rule) =>
+      rule === "<all>" ? ["<build>", "<files>", "<prerendered>"] : rule
+    )
+    .flatMap((rule) => {
+      if (rule === "<build>") {
+        return [
+          `/${builder.getAppPath()}/immutable/*`,
+          `/${builder.getAppPath()}/version.json`,
+        ];
+      }
+
+      if (rule === "<files>") {
+        return assets
+          .filter(
+            (file) =>
+              !(
+                file.startsWith(`${builder.config.kit.appDir}/`) ||
+                file === "_headers" ||
+                file === "_redirects"
+              )
+          )
+          .map((file) => `${builder.config.kit.paths.base}/${file}`);
+      }
+
+      if (rule === "<prerendered>") {
+        return builder.prerendered.paths;
+      }
+
+      return rule;
+    });
+
+  const excess = include.length + exclude.length - 100;
+  if (excess > 0) {
+    const message = `Function includes/excludes exceeds _routes.json limits (see https://developers.cloudflare.com/pages/platform/functions/routing/#limits). Dropping ${excess} exclude rules — this will cause unnecessary function invocations.`;
+    builder.log.warn(message);
+
+    exclude.length -= excess;
+  }
+
+  return {
+    version: 1,
+    description: "Generated by @sveltejs/adapter-cloudflare",
+    include,
+    exclude,
+  };
 }
 
 /** @param {string} app_dir */
 function generate_headers(app_dir) {
-	return `
+  return `
 # === START AUTOGENERATED SVELTE IMMUTABLE HEADERS ===
 /${app_dir}/*
   X-Robots-Tag: noindex
@@ -182,12 +252,12 @@ function generate_headers(app_dir) {
 
 /** @param {Map<string, { status: number; location: string }>} redirects */
 function generate_redirects(redirects) {
-	const rules = Array.from(
-		redirects.entries(),
-		([path, redirect]) => `${path} ${redirect.location} ${redirect.status}`
-	).join('\n');
+  const rules = Array.from(
+    redirects.entries(),
+    ([path, redirect]) => `${path} ${redirect.location} ${redirect.status}`
+  ).join("\n");
 
-	return `
+  return `
 # === START AUTOGENERATED SVELTE PRERENDERED REDIRECTS ===
 ${rules}
 # === END AUTOGENERATED SVELTE PRERENDERED REDIRECTS ===
@@ -195,8 +265,8 @@ ${rules}
 }
 
 function generate_assetsignore() {
-	// this comes from https://github.com/cloudflare/workers-sdk/blob/main/packages/create-cloudflare/templates-experimental/svelte/templates/static/.assetsignore
-	return `
+  // this comes from https://github.com/cloudflare/workers-sdk/blob/main/packages/create-cloudflare/templates-experimental/svelte/templates/static/.assetsignore
+  return `
 _worker.js
 _routes.json
 _headers
